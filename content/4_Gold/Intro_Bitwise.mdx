---
id: intro-bitwise
title: Intro to Bitwise Operators
description: Six bitwise operators and the common ways they are used.
author: Siyong Huang, Chongtian Ma
frequency: 3
redirects:
  - /bronze/intro-bitwise
  - /plat/intro-bitwise
---


<Resources>
	<Resource source="CPH" title="10.2 - Bit Operations" starred />
	<Resource
		source="CF"
		title="Bitwise operations for beginners"
		url="73490"
		starred
	>
		Great explanation by Errichto
	</Resource>
	<Resource
		source="GFG"
		title="Bitwise Operators in C/C++"
		url="bitwise-operators-in-c-cpp/"
	>
		The same operators are used in java and python
	</Resource>
</Resources>

At this point, you should already be familiar with the three main bitwise operators (AND, OR, and XOR).
Let's take a look at some examples to better understand them. 

<FocusProblem problem="sample" />

## Solution - Take a Guess

<Spoiler title="Hint">

Our queries are quite limited, as we can only find the AND and OR of two numbers. Maybe we can
combine the usage of these two operations to find the value of an operation that would be more
useful to us?

</Spoiler>

<Spoiler title="Solution">

In fact, we can figure out the sum of two numbers using just their AND, OR and XOR values! Suppose we know their
XOR values, we can use the following property:
	
$a + b = 2 \cdot (a \& b) + a \oplus b$

<Spoiler title="Proof">
$a \oplus b$ is essentially just $a + b$ in base $2$ but we never carry over to the next bit. Recall a bit in $a \oplus b$ is $1$ only if the bit in $a$ is different from the bit in $b$, thus one of them must be a $1$. However, when we add two $1$ bits, we yield a $0$, but we do not carry that $1$ to the next bit. This is where $a \& b$ comes in. 

$a \& b$ is just the carry bits themselves, since a bit is $1$ only if it is a $1$ in both $a$ and $b$, which is exactly what we need. We multiply this by $2$ to shift all the bits to the left by one, so every value carries over to the next bit.
</Spoiler>

To acquire the XOR values of the two numbers, we can use the following:

$a \oplus b = \lnot(a \& b) \& (a | b)$


<Spoiler title="Proof">
Recall a bit in $a \oplus b$ is $1$ only if the bit in $a$ is different from the bit in $b$. By negating $a \& b$, the bits that are left on are in the following format:

- If it is $1$ in $a$ and $0$ in $b$
- If it is $0$ in $a$ and $1$ in $b$
- If it is $0$ in $a$ and $0$ in $b$

Now this look's pretty great, but we need to get rid of the third case. By taking the bitwise AND with $a | b$, the ones that are left on is only if there is a $1$ in either $a$ or $b$. Obviously, the third case isnt included in $a | b$ since both bits are off, and we successfully eliminate that case.

</Spoiler>

Now that we can acquire the sum of any two numbers in two queries, we can easily solve the problem now. We can find the values of the first three numbers of the array using a system of equations involving their sum (note $n \geq 3$). Once we have acquired their independent values, we can loop through the rest of the array. 

</Spoiler>

<LanguageSection>
<CPPSection>

```cpp 
#include <bits/stdc++.h>
using namespace std;

int ask(string s, int a, int b) {
	cout << s << " " << a << " " << b << endl;
	int res; 
	cin >> res;
	return res;
}

// a + b = 2(a & b) + a ^ b
// a ^ b = ~(a & b) & (a | b)
int sum(int a, int b) {
	int AND = ask("and", a, b);
	int OR = ask("or", a, b);
	int XOR = ~AND & OR;
	return 2 * AND + XOR;
}

int main() {
	int n, k; 
	cin >> n >> k;
	
	// acquire first 3 elements
	int aplusb = sum(1, 2);
	int bplusc = sum(2, 3);
	int aplusc = sum(1, 3);
	
	// solve a system of equations
	vector<int> a(3);
	a[1] = (aplusb + bplusc - aplusc) / 2;
	a[0] = aplusb - a[1];
	a[2] = bplusc - a[1];
	
	// get the rest of the array
	for (int i = 4; i <= n; i++) {
		a.push_back(sum(i - 1, i) - a.back());
	}
	sort(a.begin(), a.end());
	cout << "finish " << a[k-1] << endl;
}
```
</CPPSection>
</LanguageSection>

Now let's take a look on how to implement addition and multiplication using only bitwise operators.
## Example - Addition

Try implementing addition using bitwise operators!
You can test your implementation [here](http://poj.org/problem?id=1000).

<Spoiler title="Solution">

If we perform addition without carrying, then we are simply performing the XOR
(`^`) operator. Then, the bits that we carry over are those equivalent to $1$ in
both numbers: $a\&b$.

<LanguageSection>

<CPPSection>

```cpp
int add(int a, int b) {
	while (b > 0) {
		int carry = a & b;
		a ^= b;
		b = carry << 1;
	}
	return a;
}
```

</CPPSection>

<JavaSection>

```java
public static int add(int a, int b) {
	while (b > 0) {
		int carry = a & b;
		a ^= b;
		b = carry << 1;
	}
	return a;
}
```

</JavaSection>

<PySection>

```py
def add(a: int, b: int) -> int:
	while b > 0:
		carry = a & b
		a ^= b
		b = carry << 1
	return a
```

</PySection>

</LanguageSection>

</Spoiler>

## Example - Multiplication

Now try implementing multiplication using bitwise operators!
If you want to test your implementation of multiplication,
you can do so [here](https://www.hackerrank.com/challenges/handshake/problem).

<Spoiler title="Solution">

For simplicity, we will use the `sum` functions defined above. If we divide up
$b$ into $2^{b_1}+2^{b_2}+\dots+2^{b_n}$, we get the following:

$$
\begin{align*}
&a \times b \\
&= a \times (2^{b_1}+2^{b_2}+\dots+2^{b_n}) \\
&= a2^{b_1}+a2^{b_2}+\dots+a2^{b_n} \\
&= \sum_{\text{bits in b}} {a\texttt{<<}b_i}
\end{align*}
$$

(This same idea is used in binary exponentiation!)

<LanguageSection>

<CPPSection>

```cpp
int prod(int a, int b) {
	int c = 0;
	while (b > 0) {
		if ((b & 1) == 1) {
			c = add(c, a);  // Use the addition function we coded previously
		}
		a <<= 1;
		b >>= 1;
	}
	return c;
}
```

</CPPSection>

<JavaSection>

```java
public static int prod(int a, int b) {
	int c = 0;
	while (b > 0) {
		if ((b & 1) == 1) {
			c = add(c, a);  // Use the addition function we coded previously
		}
		a <<= 1;
		b >>= 1;
	}
	return c;
}
```

</JavaSection>

<PySection>

```py
def prod(a: int, b: int) -> int:
	c = 0
	while b > 0:
		if b & 1:
			c = add(c, a)  # Use the addition function we coded previously
		a <<= 1
		b >>= 1
	return c
```

</PySection>

</LanguageSection>

</Spoiler>

<Problems problems="probs" />
