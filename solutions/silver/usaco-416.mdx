---
id: usaco-416
source: USACO Silver 2014 March
title: The Lazy Cow
author: Daniel Ge, Brad Ma, Kevin Sheng
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_lazy_silver.html)

<Spoiler title="Hint 1">
If the range of values Bessie can move to forms a square instead of this diamond, we can apply normal prefix sums.
</Spoiler>
<Spoiler title="Hint 2">
What transformation would take a diamond to a square?
</Spoiler>
<Spoiler title="Hint 3">
Apply a rotation of 45 degrees on the grid such that the cells Bessie can walk to form a square.
Note that there's one small issue that I leave to you to find and resolve (it will be covered in the solution).
</Spoiler>

## Solution
<Spoiler title="Full Solution & Implementation">
## Explanation

Apply a rotation of 45 degrees on the grid such that the cells Bessie can walk to form a square like follows:
```
     0   1   2   3   4   5   6   7   8
0  [ 0,  0,  0,  0, 50,  0,  0,  0,  0]
1  [ 0,  0,  0, 14,  0,  5,  0,  0,  0]
2  [ 0,  0, 99,  0,  3,  0, 25,  0,  0]
3  [ 0,  8,  0, 10,  0,  2,  0,  6,  0]
4  [10,  0,  7,  0, 1B,  0,  7,  0, 17]
5  [ 0,  0,  0,  5,  0,  2,  0, 21,  0]
6  [ 0,  0, 78,  0, 23,  0, 80,  0,  0]
7  [ 0,  0,  0,  1,  0, 11,  0,  0,  0]
8  [ 0,  0,  0,  0,  9,  0,  0,  0,  0]
```
What's with the zeroes?
If we simply rotate 45 degrees and cram all the cells connected diagonally into one row, then their distance becomes $1$, leading to an awkward situation like this one.
```
[99, 3, 25]
[  10, 2  ]
[ 7, 1, 7 ]
[   5, 2  ]
[78, 23,80]
```
This isn't really helpful. However, if we add a zero between, we can then forcefully re-expand the grid by a scale of 2.

This way for K = 2 centered at B like in the testcase, the range of squares that Bessie may reach is the 5x5 range in the middle.
```
[99,  0,  3,  0, 25]
[ 0, 10,  0,  2,  0]
[ 7,  0, 1B,  0,  7]
[ 0,  5,  0,  2,  0]
[78,  0, 23,  0, 80]
```
<Optional title="Thinking from a geometric standpoint">
Initially, the distance between adjacent cells is $1$ and the distance between cells connected diagonally is $\sqrt{2}$.
What we have done here is a dilation by a scale of $\sqrt{2}$, making the distance between adjacent cells now $\sqrt{2}$ and between cells $\sqrt{2} \cdot \sqrt{2} = 2$.

If we then rotate by 45 degrees and add 0s inbetween, everything falls into place. Try to visualize this in your head!
</Optional>

To calculate the sum of the numbers in these squares, which are now the shapes of squares, a first approach may be to simply "slide" the square along, adding and subtracting columns along the way.


## Implementation

**Time Complexity** $\mathcal{O}(K \cdot N ^ 2)$

<Warning>
Depending on how you implement this problem, your code might have trouble passing the last testcase(s) using this approach. There is a much faster solution below.
</Warning>

<LanguageSection>
<CPPSection>

```cpp
#include <fstream>
#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::max;
using std::min;
using std::vector;

int main() {
	std::ifstream read("lazy.in");

	int n;
	int k;
	read >> n >> k;

	// the side length needed to accomodate for the 45 degree rotation
	int new_n = 2 * n - 1;
	vector<vector<int>> field(new_n, vector<int>(new_n));

	// read input and store it rotated by 45 degrees
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) { read >> field[i + j][n - i + j - 1]; }
	}

	int start_c = n % 2 == 0 ? 1 : 0;

	long long most_grass = 0;
	for (int row = 0; row < new_n; row++) {
		long long curr_grass = 0;
		// build our initial square at the left side of the field
		for (int r = max(row - k, 0); r <= min(row + k, new_n - 1); r++) {
			for (int c = start_c; c < min(start_c + 2 * k + 1, new_n); c++) {
				curr_grass += field[r][c];
			}
		}

		// move the grid in 2-step increments and update most_grass each time
		most_grass = max(most_grass, curr_grass);
		for (int c = start_c; c + 2 * k + 1 < new_n - 1; c += 2) {
			int add_c = c + 2 * k + 1;
			for (int r = max(row - k, 0); r <= min(row + k, new_n - 1); r++) {
				// remove the two cells that bessie can't reach anymore
				curr_grass -= field[r][c] + field[r][c + 1];
				// and add the two that she now can
				curr_grass += field[r][add_c] + field[r][add_c + 1];
			}
			most_grass = max(most_grass, curr_grass);
		}

		start_c = 1 - start_c;  // alternate start_c between 1 and 0
	}

	std::ofstream("lazy.out") << most_grass << endl;
}
```

</CPPSection>
<JavaSection>

```java
import static java.lang.Math.max;
import static java.lang.Math.min;

import java.io.*;
import java.util.StringTokenizer;

public class Lazy {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("lazy");
		int n = io.nextInt();
		int k = io.nextInt();

		// the side length needed to accomodate for the 45 degree rotation
		int newN = 2 * n - 1;
		int[][] field = new int[newN][newN];

		// read input and store it rotated by 45 degrees
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				field[i + j][n - i + j - 1] = io.nextInt();
			}
		}

		int startC = n % 2 == 0 ? 1 : 0;

		long mostGrass = 0;
		for (int row = 0; row < newN; row++) {
			long currGrass = 0;
			// build our initial square at the left side of the field
			for (int r = max(row - k, 0); r <= min(row + k, newN - 1); r++) {
				for (int c = startC; c < min(startC + 2 * k + 1, newN); c++) {
					currGrass += field[r][c];
				}
			}

			// move the grid in 2-step increments and update mostGrass each time
			mostGrass = max(mostGrass, currGrass);
			for (int c = startC; c + 2 * k + 1 < newN - 1; c += 2) {
				int addC = c + 2 * k + 1;
				for (int r = max(row - k, 0); r <= min(row + k, newN - 1);
				     r++) {
					// remove the two cells that bessie can't reach anymore
					currGrass -= field[r][c] + field[r][c + 1];
					// and add the two that she now can
					currGrass += field[r][addC] + field[r][addC + 1];
				}
				mostGrass = max(mostGrass, currGrass);
			}

			startC = 1 - startC;  // alternate start_c between 1 and 0
		}

		io.println(mostGrass);
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
</LanguageSection>

However, a much faster solution is using 2D prefix sums to calculate the sum of these square in constant time. This way, we can brute force through all the squares Bessie can be and take the maximum sum.

Doing the "rotation" can be done when reading input at normal $\mathcal{O}(N ^ 2)$ time (see code below), doing the pre-processing for prefix sums takes $\mathcal{O}(N ^ 2)$ time,
while calculating the sum of each of the $N^2$ squares costs $\mathcal{O}(1)$ time for a total of $\mathcal{O}(N ^ 2)$ time.

## Implementation (Prefix Sums)

**Time Complexity** $\mathcal{O}(N ^ 2)$

<LanguageSection>
<CPPSection>

```cpp
#include <fstream>
#include <iostream>
#include <vector>

using std::endl;
using std::max;
using std::vector;

int main() {
	std::ifstream read("lazy.in");

	int n;
	int k;
	read >> n >> k;
	// the side length needed to accomodate the 45 degree rotation
	int new_n = 2 * n - 1;
	vector<vector<int>> field(new_n, vector<int>(new_n));

	// read input and store it rotated by 45 degrees
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) { read >> field[i + j][n - i + j - 1]; }
	}

	vector<vector<int>> prefix(new_n + 1, vector<int>(new_n + 1));
	for (int i = 0; i < new_n; i++) {
		for (int j = 0; j < new_n; j++) {
			prefix[i + 1][j + 1] = (field[i][j] + prefix[i + 1][j] +
			                        prefix[i][j + 1] - prefix[i][j]);
		}
	}

	int most_grass = 0;
	for (int i = k; i < new_n - k; i++) {
		for (int j = k; j < new_n - k; j++) {
			most_grass =
			    max(most_grass,
			        prefix[i + k + 1][j + k + 1] - prefix[i + k + 1][j - k] -
			            prefix[i - k][j + k + 1] + prefix[i - k][j - k]);
		}
	}

	if (k >= n) {
		// the loop above did not run, and Bessie can reach everything
		most_grass = prefix[new_n][new_n];
	}

	std::ofstream("lazy.out") << most_grass << endl;
}
```

</CPPSection>
<PySection>

<Warning>

This code may occasionally TLE on the last test case.

</Warning>

```py
import sys

sys.stdin = open("lazy.in", "r")
sys.stdout = open("lazy.out", "w")

n, k = map(int, input().split())
# the side length needed to accomodate the 45 degree rotation
new_n = 2 * n - 1
field = [[0] * new_n for _ in range(new_n)]

# read input and store it rotated by 45 degrees
for i in range(n):
	for j, x in enumerate(map(int, input().split())):
		field[i + j][n - i + j - 1] = x

prefix = [[0] * (new_n + 1) for _ in range(new_n + 1)]
for i in range(new_n):
	for j in range(new_n):
		prefix[i + 1][j + 1] = (
			field[i][j] + prefix[i + 1][j] + prefix[i][j + 1] - prefix[i][j]
		)

most_grass = 0
for i in range(k, new_n - k):
	for j in range(k, new_n - k):
		most_grass = max(
			most_grass,
			prefix[i + k + 1][j + k + 1]
			- prefix[i + k + 1][j - k]
			- prefix[i - k][j + k + 1]
			+ prefix[i - k][j - k],
		)

if k >= n:
	# the loop above did not run, and Bessie can reach everything
	most_grass = prefix[new_n][new_n]

print(most_grass)
```

</PySection>
</LanguageSection>
</Spoiler>
