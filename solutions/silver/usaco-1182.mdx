---
id: usaco-1182
source: USACO Silver 2022 January
title: Searching for Soulmates
author: Chongtian Ma, Chuyang Wang
---

[Official Analysis (Java)](http://www.usaco.org/current/data/sol_prob1_silver_jan22.html)


## Explanation

To transform $a$ into $b$, we proceed greedily. If $a > b$, it can be shown that
it is never optimal to add more than once consecutively before dividing $a$ by
2. Then, if $a < b$, we can simulate our strategy above by allowing
multiplication, division, and subtraction by one on $b$. We therefore either
divide $b$ by two (and first subtract by one if $b$ is odd) or subtract $b$ $b -
a$ times to directly reach $a$. 

## Implementation

**Time Complexity:** $\mathcal{O}(N \log{\log\max(A, b)})$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

ll solve(ll a, ll b) {
	if (a == b) {
		return 0;
	} else if (a > b) {
		/*
		 * Divide a greedily until a <= b, add 1 in case a is odd to enable
		 * division. 
		 */
		ll isOdd = a % 2;
		return 1 + isOdd + solve((a + isOdd) / 2, b);
	} else {
		/*
		 * Otherwise, simulate multiplication of a by dividing b.
		 * Alternatively, if it's better, add up to b directly. 
		 */
		ll isOdd = b % 2;
		return min(b - a, 1 + isOdd + solve(a, b / 2));
	}
}

int main() {
	int N;
	cin >> N;
	for (int i = 0; i < N; i++) {
		ll a, b;
		cin >> a >> b;
		cout << solve(a, b) << endl;
	}
}
```

</CPPSection>
<JavaSection>

```java

```

</JavaSection>
<PySection>

```py

```

</PySection>
</LanguageSection>
