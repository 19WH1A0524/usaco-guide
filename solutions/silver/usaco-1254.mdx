---
id: usaco-1254
source: USACO Silver 2022 December
title: Barn Tree
author: Aditya Gupta
---

## Explanation

In order for each barn to have the same number of hay bales, each barn must have the average number of bales. Also, in any optimal solution, there will be at most one order for each edge.

Thus, we can DFS from an arbitrary root. At each node, we calculate the number of bales the barn needs to either transport from its children to its parent or the number of bales it needs to transport from its parent to its children, and store this as an order.

However, we also need to make sure that we print a valid ordering of these orders, so that a barn does not have negative hay bales at any moment. To do this, we keep track of the incoming and outgoing orders for each node, and construct a directed graph of these. Then, DFS from any unvisited node, and recurse on every barn that the node has an incoming order from (that hasn't been visited). Finally, print the barn's outgoing orders.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

#define f first
#define s second
const int MAX_N = 2e5;

using ll = long long;
using pi = pair<ll, ll>;

vector<ll> adj[MAX_N];
vector<ll> ordersFrom[MAX_N];  // Stores for each barn the barns that it receives an order from
vector<pi> ordersTo[MAX_N];  // Stores for each barn its outgoing orders

ll bales[MAX_N];
bool visited[MAX_N];
ll n, cnt;

// Move hay bales and generate orders
ll dfs(ll node, ll prev) {
	ll balesToMove = bales[node];
	for (ll i : adj[node]) {
		if (i == prev) {
			continue;
		}
		ll childBales = dfs(i, node);
		balesToMove += childBales;

		// move bales from barn i to node
		if (childBales > 0) {
			ordersFrom[node].emplace_back(i);
			ordersTo[i].emplace_back(node, childBales);
			cnt++;
		} else if(childBales < 0) {  // move bales from node to barn i
			ordersFrom[i].emplace_back(node);
			ordersTo[node].emplace_back(i, -1 * childBales);
			cnt++;
		}
		// if childBales is 0, we don't need to move any orders
	}
	return balesToMove;
}

/*
 * For each barn, we print out all outgoing orders of the barns it receives an order from.
 * This ensures that we always have a valid ordering of orders.
*/
void printOrders(ll node) {
	visited[node] = true;
	for (ll i : ordersFrom[node]) {
		if(!visited[i]) printOrders(i);
	}
	for (const pi& i : ordersTo[node]) {
		cout << node + 1 << ' ' << i.f + 1 << ' ' << i.s << '\n';
	}
}


int main() {
	cin >> n;
	ll avg = 0;
	for (ll i = 0; i < n; i++) {
		cin >> bales[i];
		avg += bales[i];
	}
	avg /= n;

	for (ll i = 0; i < n; i++) {
		bales[i] -= avg;
	}

	for (ll i = 1; i < n; i++) {
		ll u, e;
		cin >> u >> e;
		adj[u - 1].emplace_back(e - 1);
		adj[e - 1].emplace_back(u - 1);
	}

	dfs(0, -1);
	cout << cnt << endl;

	for (ll i = 0; i < n; i++) {
		if (!visited[i]) {
			printOrders(i);
		}
	}
}
```

</CPPSection>
</LanguageSection>
