---
id: cf-1666F
source: CF
title: Fancy Stack
author: Aakash Gokhale
---

[Official Editorial](https://codeforces.com/contest/1666/attachments/download/15881/nerc-2021-tutorial.pdf)

## Explanation

First we can solve an easier version of the problem where all the blocks are distinct.

Process the blocks from largest to smallest.

We can do this problem using dynamic programming.
Let $dp[i][j]$ be the number of ways to use the first $i$ blocks and place $j$ of those in the $j$ bottommost even positions (and $i - j$ of them in the odd position).

There are two transitions.

1. To $dp[i + 1][j + 1]$. If we add another even block, then there is only one place to put it.

2. To $dp[i + 1][j]$. In this case we add the block to an odd position.
Notice that we must place a block in between already placed larger blocks because of the condition that an even block is greater than its two neigboring odd blocks and later placed blocks will always be smaller.
This means that there will be $max(0, j - 1)$ positions to insert the block. When all $\frac{n}{2}$ even blocks are placed you can also insert it at the top of the stack.
We also have to subtract out the $i - j$ blocks that are already placed in odd positions.

When the blocks can be of the same size, let's process them in groups of blocks that are all the same size.

There are still two possible transitions.
Either we put one block into an even position and the remaining into odd or all of them into odd positions.

To determine the number of ways to insert the blocks into the odd positions, we can evaluate ${\textbf{number of open spots} \choose \textbf{number of spots that we want to fill}}$.

Our answer will be $dp[n][\frac{n}{2}]$.

**Time Complexity:** $\mathcal{O}(n^2)$

## Implementation

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
using ll = long long;
 
const ll MOD = 998244353;
 
const int MAXN = 5000;
	
// https://usaco.guide/gold/combo?lang=cpp
ll F[MAXN + 1];
ll IVF[MAXN + 1];
 
ll binpow(ll a, ll b) {
	if (b < 0) return 1;
	ll res = 1;
	while (b) {
		if (b & 1) res = (res * a) % MOD;
		a = (a * a) % MOD;
		b >>= 1;
	}
	return res;
}
 
ll choose(ll a, ll b) {
	if (a < b) return 0;
	return ((F[a] * IVF[b]) % MOD * IVF[a - b]) % MOD;
}
 
void solve() {
	int n;
	cin >> n;
	vector<int> a(n);
	for (auto & i: a) cin >> i;
	reverse(a.begin(), a.end());
	vector<pair<int, ll>> b;
	for (int i = 0; i < n; i++) {
		if (b.size() > 0 && b.back().first == a[i]) {
			b.back().second++;
		} else {
			b.push_back({a[i], 1ll});
		}
	}
	// i greatest are used, j are even spots, i - j are odd spots
	vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0ll));
	dp[0][0] = 1; 
	ll size = 0;
	for (int i = 0; i < ((int) b.size()); i++) {
		for (ll j = 0; j <= size; j++) {
			ll positions = max(j - 1, 0ll) + (j == n / 2) - (size - j);
			// k in the even position and b[i].second - k in the odd
			for (ll k = 0; k <= 1; k++) { 
				if (j + k > n / 2) {
					continue;
				}
				dp[size + b[i].second][j + k] = (
					dp[size + b[i].second][j + k] 
					+ choose(positions, b[i].second - k)
					* dp[size][j] % MOD
				) % MOD;
			}
		}
		size += b[i].second;
	}
	cout << dp[n][n / 2] << endl;
}
 
int main() {
	F[0] = 1;
	for (ll i = 1; i <= MAXN; i++) {
		F[i] = (F[i - 1] * i) % MOD;
	}
	for (ll i = 0; i <= MAXN; i++) {
		IVF[i] = binpow(F[i], MOD - 2);
	}
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		solve();
	}
}

```
</CPPSection>
</LanguageSection>
