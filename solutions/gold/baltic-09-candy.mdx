---
id: baltic-09-candy
source: Baltic OI 2009
title: Candy Machine
author: Panos Paskalis
---

[Official Analysis] (http://www.csc.kth.se/contest/boi/candy-spoiler.pdf)

## Observation 

If there is a candy $i$ $(s_i, t_i)$ and a candy $j$ $(s_j, t_j)$, with
$t_i < t_j$, then $j$ can be caught by the same wagon as $i$, if the distance
between them can be covered by the wagon in $t_j - t_i$ time. That is:

$$
|s_j - s_i| \leq t_j - t_i \iff
t_i - t_j \leq s_j - s_i \leq t_j - t_i \iff
$$
$$
\begin{cases}
    s_i + t_i \leq s_j + t_j \text{ and } \\
    s_j - t_j \leq s_i - t_i \\
\end{cases}
$$
Since $t_i \geq 0$,
$$
s_i - t_i \leq s_i + t_i
$$
In total:
$$
s_j - t_j \leq s_i - t_i \leq s_i + t_i \leq s_j + t_j
$$


## Finding the minimum number of wagons

If we think of each candy as a segment $[s - t, s + t]$ 
(note that each candy corresponds to a unique segment and vice versa), we can
conclude that then candy $j$ can be caught by the same wagon as candy $i$ if
the segment of $i$ is nested inside the segment of $j$.
Therefore a wagon can catch a sequence of candies $c_1, c_2, ..., c_k$
if they form a sequence of nested segments. It follows that the minimum number
of wagons needed is the longest sequence of non-nested segments.

Two segments $[l_1, r_1]$, $[l_2, r_2]$ that are not nested adhere to:
$$l_1 < l_2 \implies r_1 < r_2$$.


If we sort the candies by the left endpoint of their segments such that
$$
l_1 \leq l_2 \leq ... \leq l_n
$$
then a sequence of non-nested segments would correspond to an increasing
sequence of right endpoints. Therefore, the minimum number of required wagons
would correspond to the length of the longest increasing sequence of right
endpoints. 

## Assigning the candies to wagons

By following the binary search algorithm described in
[the LIS module](/gold/lis), we can assign the candies with the same LIS
length in the same wagon. The segments that have the same LIS length cannot be
nested. If they were, we could use the inside segment to increase the LIS of
the outside one by 1.

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<Warning>
Watch out for the case $l_i = l_j$, in which case we must sort by decreasing
right endpoint to ensure they would not be counted as non-nested segments.
</Warning>

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
#define MAXN 100000

using namespace std;

typedef pair<int, int> ii;

int n;
ii candies[MAXN + 2];
int lis[MAXN + 2];
vector<ii> candies_caught[MAXN + 2];


// NOTE: It is important to sort segments of same left point by decreasing 
// right point so they count as nested
bool compare_segments(ii a, ii b)
{
    if (a.first == b.first)
        return a.second > b.second;

    return a.first < b.first;
}

int main(void)
{
    scanf("%d", &n);
    int s, t;
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &s, &t);
        candies[i] = make_pair(s - t, s + t);
    }

    // Sort the segments by left endpoint
    sort(candies, candies + n, compare_segments);

    for (int len = 0; len <= n; len++)
        lis[len] = INT_MAX;
    lis[0] = 0;
    for (int i = 0; i < n; i++) {
        int r_point = candies[i].second;
        
        int l = 0; // Condition: lis[l] < r_point
        int r = n; // Condition: lis[r] >= r_point
        while (r > l + 1) {
            int mid = (l + r) / 2;
            if (lis[mid] < r_point)
                l = mid;
            else 
                r = mid;
        }

        lis[l+1] = r_point;
        // Candies with the same lis length can be caught by the same wagon
        candies_caught[l+1].push_back(candies[i]);
    }

    int ans = 0;
    while (ans < n && lis[ans + 1] != INT_MAX)
        ans++;

    printf("%d\n", ans);
    for (int len = 1; len <= ans; len++) 
        for (ii c : candies_caught[len]) {
            // Convert the segments back to s and t
            int s = (long long)(c.first + c.second) / 2;
            int t = (long long)(c.second - c.first) / 2;

            printf("%d %d %d\n", s, t, len);
        }
    
    return 0;
}
```

</CPPSection>
</LanguageSection>