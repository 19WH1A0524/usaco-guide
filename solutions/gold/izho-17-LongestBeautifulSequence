---
id: izho-17-LongestBeautifulSequence
source: IZhO
title: Longest Beautiful Subsequence
author: Daniel Zhu
---

## Explanation
### Subtasks 1-2
Due to the small bounds on $N$, an $\mathcal{O}(N^2)$ solution suffices. 

Define $\texttt{dp}[i]$ as the length of the longest LBS (longest beautiful subsequence) that ends at $i$, and $\texttt{bc}[x][y]$ as $\text{bit\_count}(x \hspace{3pt} \& \hspace{3pt} y)$. We transition by iterating over all $j < i$ where $\texttt{bc}[a_i][a_j] == \texttt{k}[i]$. 

We can reconstruct an optimal solution by defining another array $\texttt{prv}$, where $\texttt{prv}[i]$ is the most optimal index to include directly before index $i$.

**Time Complexity**: $\mathcal{O}(N^2)$
<Spoiler title="Code">
<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	vector<int> k(n);
	for (int i = 0; i < n; i++) {
		cin >> k[i];
	}

	vector<int> dp(n, 1);
	// best_i: most optimal index to end on
	int ans = 1, best_i = 0;
	// prv[i] = optimal index to include right before i 
	vector<int> prv(n);
	// intially, prv[i] = i
	iota(prv.begin(), prv.end(), 0);

	for (int i = 1; i < n; i++) {
		for (int j = 0; j < i; j++) {
			// bc[a[j]][a[i]] == k[i]
			if (__builtin_popcount(a[j] & a[i]) == k[i]) {
				if (dp[j] + 1 > dp[i]) {
					prv[i] = j;
					dp[i] = dp[j] + 1;
				}
			}
		}
		if (dp[i] > ans) {
			ans = dp[i];
			best_i = i;
		}
	}
	
	cout << ans << endl;
	vector<int> res;
	while (prv[best_i] != best_i) {
		res.push_back(best_i);
		best_i = prv[best_i];
	}
	res.push_back(best_i);
	reverse(res.begin(), res.end());
	for (int x : res) cout << x + 1 << " ";
}

```
</CPPSection>
</LanguageSection>
</Spoiler>
### Subtask 3
While the bounds on $N$ are now much larger ($N \leq 10^5$), the maximum value of $a_i$ is now only $M = 2^8$. We can use this to optimize our solution: rather than looping over every possible previous index, we can loop over all possible previous values instead. 

More specifically, we redefine $\texttt{dp}[i]$ to be the length of the longest LBS that ends with **value** $i$ (rather than index). To calculate $\texttt{dp}[a_i]$, we try to transition from $\texttt{dp}[j]$ for all $j$ that satisfy $bc[j][a_i] == k[i]$. This improves our time complexity to $\mathcal{O}(NM)$.

**Time Complexity**: $\mathcal{O}(NM)$
<Spoiler title="Code">
<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
#define f first
#define s second
using namespace std;
using pii = pair<int, int>;
const int B = 8;

int main() {
    // preprocess: 
	// bc[i][j] = bit_count(i & j)
	vector<vector<int>> bc(1 << B, vector<int>(1 << B));
    for (int i = 0; i < (1 << B); i++) {
        for (int j = 0; j < (1 << B); j++) {
            bc[i][j] = __builtin_popcount(i & j);
        }
    }

	int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    vector<int> k(n);
    for (int i = 0; i < n; i++) cin >> k[i];
    int ans = 1, best_i = 0; // best_i: best index to end subsequence at
    vector<int> prv(n); // prv[i]: best index to include before i
    iota(prv.begin(), prv.end(), 0); // prv[i] = i
	vector<pii> dp(1 << B, make_pair(-1, -1));
	// dp[i].f: longest lbs that ends in i
	// dp[i].s: optimal end index for lbs that ends in i

    for (int i = 0; i < n; i++) {
		if (dp[a[i]].f == -1) {
			dp[a[i]].f = 1;
			dp[a[i]].s = i;
		}
        for (int j = 0; j < (1 << B); j++) {
            if (bc[j][a[i]] == k[i] && dp[j].f + 1 > dp[a[i]].f) {
				dp[a[i]].f = dp[j].f + 1;
				dp[a[i]].s = i;
				prv[i] = dp[j].s;
			}
        }
        if (dp[a[i]].f > ans) {
            ans = dp[a[i]].f;
            best_i = i;
        }
    }
    cout << ans << endl;
    vector<int> res;
    while (prv[best_i] != best_i) {
        res.push_back(best_i);
        best_i = prv[best_i];
    }
    res.push_back(best_i);
    reverse(res.begin(), res.end());
    for (int x : res) cout << x + 1 << " ";
}
```
</CPPSection>
</LanguageSection>
</Spoiler>
### Subtask 4 (Full Credit)
With much higher bounds on both $N$ and $M$, neither of the previously presented solutions will run in time.

In our solution for Subtask 3, the loop from $0...M$ seems repetitive and motivates somehow restricting the search space of DP states. The most extreme way to achieve this is to embed all search parameters directly in the DP state (i.e. $\texttt{dp}[i][k]$ is the length of the longest LBS that ends in $x$, where $\texttt{bc}[x][i] == k$). $\texttt{dp}[a[i]][k[i]]$ is now an $\mathcal{O}(1)$ transition to find the longest LBS that ends at index $i$. However, each DP state now encapsulates a much larger amount of possible LBS's: any LBS that ends in $x$, where $\texttt{bc}[x][i] == k$, will be factored into $\texttt{dp}[i][k]$. Similarly, an LBS with fixed final value $a_i$ now affects $M$, rather than $1$, DP states: namely, all states $\texttt{dp}[x][k]$ where $x \in [0, M)$ and $k = \texttt{bc}[a[i]][x]$. 

In summary, if $a_i$ is the last number in an LBS:
- strict DP state (only 1 possible value of $a_i$) -> $\mathcal{O}(M)$ transition, $\mathcal{O}(1)$ affected states
- loose DP state (up to $M$ possible values of $a_i$) -> $\mathcal{O}(1)$ transition,  $\mathcal{O}(M)$ affected states

Notice that, no matter how we define the DP state, these two complexities will always multiply to $\mathcal{O}(M)$. Therefore, we want to find a state such that both complexities are $\mathcal{O}(\sqrt{M})$. 

Based on the two extremes we considered, increased restriction on $x$ (the last number in the LBS) appears to directly correspond to a lower amount of affected states. In fact, if we restrict $b$ bits of $x$, the complexity of transition is $\mathcal{O}(2^b)$, and the amount of affected states is $\mathcal{O}(\frac{M}{2^b})$. Therefore, $\frac{\log_2M}{2} = 10$ is the best value for $b$, giving a final time complexity of $\mathcal{O}(N\sqrt{M})$.

**Time Complexity:** $\mathcal{O}(N\sqrt{M})$
<Spoiler title="Code">
<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
#define f first
#define s second
using namespace std;
using pii = pair<int, int>;
const int N = 1e5;
const int B = 10;
int bc[1 << B][1 << B]; // bc[i][j] = bit_count(i & j)
pii dp[1 << B][1 << B][B + 1];
// define l(x) = 10 leftmost bits of x, 
// and r(x) = 10 rightmost bits of x
// dp[i][j][k].f:
// longest subsequence that ends in x, where x satisfies:
// 1) l(x) = i
// 2) bc[r[x]][j] = k
// dp[i][j][k].s:
// index of the most optimal x

int main() {
    // preprocess: 
    for (int i = 0; i < (1 << B); i++) {
        for (int j = 0; j < (1 << B); j++) {
            bc[i][j] = __builtin_popcount(i & j);
        }
    }

	int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    vector<int> k(n);
    for (int i = 0; i < n; i++) cin >> k[i];
    int ans = 1, best_i = 0; // best_i: best index to end subsequence at
    vector<int> prv(n); // prv[i]: best index to include before i
    iota(prv.begin(), prv.end(), 0); // prv[i] = i

    for (int i = 0; i < n; i++) {
        int l = a[i] >> 10, r = a[i] % (1 << 10); // l(a[i]), r(a[i])
        int lbs = 1; // length of longest lbs that ends at i

        // enumerate all possibilities for l(prev_num)
        for (int j = 0; j < (1 << B); j++) {
            // here, we use the fact that 
            // bc[x][y] = bc[l(x)][l(y)] + bc[r(x)][r(y)],
            // or bc[r(x)][r(y)] = bc[x][y] - bc[l(x)][l(y)]
			
			// required value of bc[r(x)][r(y)]
            int needed = k[i] - bc[j][l];
            if (needed < 0 || needed > 10) continue;
            if (dp[j][r][needed].f + 1 > lbs) {
                lbs = dp[j][r][needed].f + 1;
                prv[i] = dp[j][r][needed].s;
            }
        }

        if (lbs > ans) {
            ans = lbs;
            best_i = i;
        }

        // update all answers a[i] affects
        for (int j = 0; j < (1 << B); j++) {
            pii& new_state = dp[l][j][bc[r][j]];
            if (lbs > new_state.f) {
                new_state.f = lbs;
                new_state.s = i;
            }
        }
    }
    cout << ans << endl;
    vector<int> res;
    while (prv[best_i] != best_i) {
        res.push_back(best_i);
        best_i = prv[best_i];
    }
    res.push_back(best_i);
    reverse(res.begin(), res.end());
    for (int x : res) cout << x + 1 << " ";
}
```
</CPPSection>
</LanguageSection>
</Spoiler>
