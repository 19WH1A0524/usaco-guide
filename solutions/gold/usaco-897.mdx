---
id: usaco-897
source: USACO Gold 2019 January
title: Cow Poetry
author: Jeffrey Zhang
---

[Official Analysis](http://www.usaco.org/current/data/sol_poetry_gold_jan19.html)


## Solution

Let us first observe that the *order of the words* beside the last word in each line is independent from the *order of the lines* in the poetry. Meaning we can take this problem apart into two distinct problems.

1. Define $f(i)$ that calculates the total possible ways selected words can be arranged in a line that ends with a certain rhyme class $c_i$
2. Calculate the final answer by figuring out different ways to map rhyme class $c$ to rhyme scheme $e$.

Here is what I mean by using the sample testcase input as an example:
```
3 3 10
3 1
4 1
3 2
A
B
A
```

There are $8$ different ways to juggle the words such that a line ends with a word with rhyme class $1$, and $4$ ways for class $2$. So $f(1) = 8$ and $f(2) = 4$.

We can map the rhyme class to scheme in four different ways. Allowing us to obtain $f(1)^3 + f(1)^2f(2) + f(2)^2f(1) + f(2)^3 = 960$.

### Part 1
Now we have a clear understanding of what we are dealing with, let us first begin by tackle the first part of our problem. The intuition behind this part is similar to that of a knapsack variant. We are asked given a constraint of total length $k$, where each word have varied syllables $s_i$, we need find the total number of ways to fit selected words together so the total syllables of all the words is exactly $k$ letters long.

Let $dp[i]$ be the total number of ways to fit a total length $i$, and $p[j]$ represents the number of words with $j$ syllables. We can find the relationship between each state as

$dp[i] = \sum_{j=0}^{i} dp[i-j] \cdot p[j]$.

$dp[k]$ tells us the number of ways to fits words under length $k$, but it doesn't specify what is the ending word's rhyme class. To do that, we can simply write

$f(i) = \sum_{j=0}^{k} dp[k-j] \cdot p_i[j]$.

### Part 2
For this second part, we need to first make the observation that given any rhyme scheme, the final answer they produce is equivalent to if any two lines of the scheme is switched. This is true because the combinations that one line can have does not affect any other line, meaning they are indpendent!

So to make our calculations easier, we can just sort the rhyme scheme, count the number of lines that have the same type and put them in a set call it $q$. In our example $q = [2, 1]$.

To calculate our final answer, we just need to find the sum to this polynomial right here, and keep it simple, let us just assume total number of rhyme classes is $2$.

$f(1)^{q_1+ \dots +q_k} + f(1)^{q_1 + \dots + q_{k-1}} f(2)^{q_k} + \dots + f(1)^{q_k} f(2)^{q_1 + \dots + q_{k-1}} + f(2)^{q_1+ \dots + q_k}$.

But now comes a new hurdle, this polynomial seems very daunting and we can quickly see the number of terms does not grow linearly as the number of rhyme classes grows.

In order to finish this final section of our problem, we need to make the observation that this polynomial is actually symmetrical, and we can instead express the expression as products of power series

$(f(1)^{p_1} + f(2)^{p_1})(f(1)^{p_2} + f(2)^{p_2}) \cdots (f(1)^{p_k} + f(2)^{p_k})$.

When we expand this out, we can get the exact same distribution of the powers in the polynomial above.


<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

// A O(log(b)) method for modular exponentiation
ll fastmod(ll a, ll b) {
	if (a == 0) return 0;
	ll track = 1;
	while (b) {
		if (b & 1) track = (track * a) % (ll)(1e9 + 7);
		a = (a * a) % (ll)(1e9 + 7);
		b = b >> 1;
	}
	return track;
}

int main() {
	ofstream fout("poetry.out");
	ifstream fin("poetry.in");

	// Keep track how many words with same syllables and how many words in the
	// same rhyme class
	int n, m, k;
	fin >> n >> m >> k;
	vector<ll> count(k + 1, 0);
	vector<vector<ll>> type(n + 1);
	for (int i = 0; i < n; i++) {
		int a, b;
		fin >> a >> b;
		count[a]++;
		type[b].push_back(a);
	}
	vector<int> rhyme(m);
	for (int i = 0; i < m; i++) {
		char a;
		fin >> a;
		rhyme[i] = int(a - 'A');
	}

	// First part
	vector<ll> dp(k + 1, 0);
	dp[0] = 1;
	for (int i = 1; i <= k; i++) {
		for (int j = 1; j <= i; j++) {
			dp[i] = (dp[i] + (dp[i - j] * count[j])) % (ll)(1e9 + 7);
		}
	}
	vector<ll> total(n + 1, 0);
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < type[i].size(); j++) {
			total[i] = (total[i] + dp[k - type[i][j]]) % (ll)(1e9 + 7);
		}
	}
	if (dp[k] == 0) {
		fout << 0;
		return 0;
	}

	// Second part
	sort(rhyme.begin(), rhyme.end());
	vector<int> groups;
	rhyme.push_back(-1);
	int back = 0;
	for (int i = 1; i <= m; i++) {
		if (rhyme[i] != rhyme[i - 1]) {
			groups.push_back(i - back);
			back = i;
		}
	}
	ll ans = 1;
	for (int i = 0; i < groups.size(); i++) {
		ll curr = 0;
		for (int j = 1; j <= n; j++) {
			curr = (curr + fastmod(total[j], groups[i])) % (ll)(1e9 + 7);
		}
		ans = (ans * curr) % (ll)(1e9 + 7);
	}

	fout << ans;

	return 0;
}
```

</CPPSection>
</LanguageSection>
