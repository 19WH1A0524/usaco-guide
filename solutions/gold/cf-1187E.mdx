---
id: cf-1187E
source: CF
title: Tree Painting
author: Yash Singh
---

[Official Editorial](https://codeforces.com/blog/entry/68111)

## Explanation

We notice that choosing a vertice splits the current connected component into the childrens' subtrees and the rest of the tree excluding the current subtree. Another observation we can make is that choosing a leaf node is more optimal than choosing anything in the middle because that way we have the entire size of the rest of the tree as a part of the leftover connected component. This hints for a DP on Trees solution, we choose one leaf node, work our way up and work our way down for each of the siblings. For example, for the following tree:

![Tree Visualization](cf-1187E/tree.png)

If we select the 4th node as our starting point, then the process would look like the following:

1. Work our way up to 3
2. Work our way down to 5
3. Work our way up to 1
4. Work our way down to 2

We need to maintain the cost of two different scenarios: working up and working down, meaning that we have to maintain 2 DP arrays. Let's define the DP transitions for each of the arrays. We will use $dp_1$ for the cost of working down and $dp_2$ for the cost of work up and $sz$ for the size of a subtree.

$$
sz[u] = 1 + \sum_{c\in child(u)} sz[c] \newline
dp_1[u] = sz[u] + \sum_{c\in child(u)} dp_1[c]
$$

We can calculate this DP array with a single DFS search. Now, for the second DP array:

$$
dp_2[u] = \max_{c\in child(u)} (sz[u] - sz[c] + dp_2[c] + \sum_{d\in child(u), c\neq d}dp_1[d])
$$

There is still one problem though. The cost of $sz[u] - sz[c]$ is applied the number of times the initially chosen node is deep compared to $u$. However, we can't anticipate this number beforehand, and we might have some ancestor node later on which would have prefered a higher depth over a higher cost. This means that we need to incorporate the $sz[u] - sz[c]$ for every ancestor node when initializing the $dp_2$ value for leaf nodes. That way we, it will be incorporated into the cost beforehand and we don't need to worry about choosing the wrong initial node with an inoptimal ending cost. We can calculate these initial values with another DFS search before the one calculating the values for $dp_2$. That way we can remove the $sz[u] - sz[c]$ from the recurrence formula for $dp_2$.

## Implementation

**Time Complexity:** $\mathcal{O}(V+E)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

vector<vector<ll>> g;
vector<ll> dp1, dp2;
vector<ll> prec1, prec2;
vector<ll> sz;

// Calculate sz and dp1
void dfs1(ll u, ll p) {
  sz[u] = 1;
  for (auto &v: g[u]) {
    if (v == p) continue;
    dfs1(v, u);
    sz[u] += sz[v];
    dp1[u] += dp1[v];
  }
  dp1[u] += sz[u];
}

// Calculate cost incorporated for initial value of dp2
void dfsmd(ll u, ll p) {
  if (p != -1) {
    prec1[u] = prec1[p] + sz[p] - sz[u];
    prec2[u] = prec2[p] + prec1[u] + sz[p] - sz[u];
  }
  for (auto &v: g[u]) {
    if (v == p) continue;
    dfsmd(v, u);
  }
}

// Calculate dp_2
void dfs2(ll u, ll p) {
  dp2[u] = (g[u].size() == 1 ? prec2[u]+1 : 0);
  ll tot{0};
  for (auto &v: g[u]) {
    if (v == p) continue;
    tot += dp1[v];
  }
  for (auto &v: g[u]) {
    if (v == p) continue;
    dfs2(v, u);
    if ((dp2[v] + tot - dp1[v]) > dp2[u]) {
      dp2[u] = (dp2[v] + tot - dp1[v]);
    }
  }
}

int main() {
  ios_base::sync_with_stdio(false);

  ll n;
  cin >> n;

  g.resize(n); dp1.resize(n); dp2.resize(n); sz.resize(n);
  prec1.resize(n); prec2.resize(n);

  ll x, y;
  for (ll i{1}; i < n; ++i) {
    cin >> x >> y; --x; --y;
    g[x].push_back(y);
    g[y].push_back(x);
  }

  dfs1(0, -1);
  dfsmd(0, -1);
  dfs2(0, -1);

  ll ans{0};
  for (ll i{0}; i < n; ++i) {
    ans = max(ans, max(dp1[i], dp2[i]));
  }

  cout << ans << '\n';

  return 0;
}
```

</CPPSection>

</LanguageSection>
