---
id: usaco-1210
source: USACO Gold 2022 February
title: Cow Camp
author: Aakash Gokhale
---

[Official Analysis](http://usaco.org/current/data/sol_prob2_gold_feb22.html)

## Solution
We can subtract $1$ from $T$ because we will always get the sample test case and add it to our final answer.

Let $E_x$ be the expected value of $x$ submissions. We are trying to find $E_k$. To get the expected value of the final submission, we can find the relation between $E_x$ and $E_{x - 1}$.


To do this we can find $E_x$ in terms of $E_{x -1}$ and $p_i$ which is the probability of getting exactly $i$ test cases.


The general rule is to resubmit only if the amount of test cases is less the expected value after $x$ submissions and to not resubmit if it is greater than the expected value. The equality case doesn't matter so we can just change less than into less than or equal (or greater than into greater or equal to).


So the first part of the expected value expression will be the sum of probabilities that the number of test cases is less than or equal to $E_{x - 1}$ multiplied by the expected value of $E_{x - 1}$.


The second part of the the expected value expression will the be the sum of the probabilities multiplied by the actual value of test cases that are greater than the expected value of $E_{x - 1}$.


So our final expression is

$$E_x = E_{x -1} \cdot \sum_{i=0}^{\lfloor E_{x - 1} \rfloor} p_i + \sum_{i=\lfloor E_{x - 1} + 1 \rfloor}^{T} i p_i$$

We can solve the problem by simulating each test case and recalculating the summations for each test case in $O(TK)$. However, this can easily be sped up to $O(T^2 + K)$ by pre-calculating $p_i$ using Pascal's identity and by precalculating the prefix sums of both $p_i$ and $p_i i$ so we can get the values of the summations in $O(1)$ instead of $O(T)$. This gives us the first $9$ test cases but is not good enough.

In order to fully solve the question, we need to remove the $O(K)$ factor. We can do this if we are able to process multiple values of $E_x$ in a single step.

Claim: We can only do this if the values of $a = {\sum_{i=0}}^{\lfloor E_{x - 1} \rfloor} p_i$ and $b = {\sum_{i=\lfloor E_{x - 1} + 1 \rfloor}}^{T} i p_i$ don't change between queries.

Proof:
Let $a = {\sum_{i=0}}^{\lfloor E_{x - 1} \rfloor} p_i$ and $b = {\sum_{i=\lfloor E_{x - 1} + 1 \rfloor}}^{T} i p_i$. Then our formula becomes

$E_x = E_{x - 1} \cdot a + b$

Since $a$ and $b$ are constant, we can extend this formula and get

$E_x = a \cdot (a \cdot ... (a \cdot E_{x - k} + b) ... + b) + b$

Simplifying gives us a geometric sequence.

$E_x = a^k \cdot E_{x - k} + a^{k - 1}b + a^{k - 2} + ... + b$

We can rewrite the second through last term using the formula for a geometric series.

$E_x = a^k \cdot E_{x - k} + \frac{b(a^k - 1)}{a - 1}$

Here is more information about geometric series: https://artofproblemsolving.com/wiki/index.php/Geometric_sequence.

However, the values of $a$ and $b$ won't always remain the same. We can binary search on the max number of submissions Bessie can make before the values of $a$ and $b$ change. $a$ and $b$ will change when the value$\text{ of } {\lfloor E_x \rfloor}$ changes. The conditions for binary search are fullfilled because $E_x$ is an non-decreasing function.

Since there are at most $T$ values of $E_x$, $a$ and $b$ can change at most $T$ times so the resulting time complexity will be $O(T^2 + T \log K)$.

## Implementation
**Time Complexity:** $\mathcal{O}(T^2 + T \log K)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using db = double;

db prob[1001][1001];
db pref_prob[1001];
db pref_exp[1001];

// Function to skip ahead x submissions with constants a and b with the current expected value set to E.
db skip_submissions(db a, db b, db E, ll x) {
  	return pow(a, x) * E + b * (pow(a, x) - 1) / (a - 1);
}

int main() {
	int T;
	ll K;
	cin >> T >> K;
	
	// Subtract sample test case
	T--;
	
	// Precompute probablity of choosing exactly i test cases using Pascal's Identity.
	prob[0][0] = 1;
	for (int i = 1; i <= T; i++) {
		prob[i][0] = prob[i - 1][0] / 2;
		for (int j = 1; j <= T; j++) prob[i][j] = (prob[i - 1][j] + prob[i - 1][j - 1]) / 2;
	}
  
	// Create prefix sum of probablity
	pref_prob[0] = prob[T][0];
	for (int i = 1; i <= T; i++) pref_prob[i] = pref_prob[i - 1] + prob[T][i];
						
	// Create prefix sum of expected value
	pref_exp[0] = 0;
	for (int i = 1; i <= T; i++) pref_exp[i] = pref_exp[i - 1] + prob[T][i] * i;
  
	db E = 0;
	while (K != 0) {
		/*
		Find the floor of the current expected value
		which acts as the limit of how many submissions we can skip forward.
		*/ 
		ll cross = (ll) floor(E);

		// Find constants a and b
		db a = pref_prob[cross], b = pref_exp[T] - pref_exp[cross];

		// Binary search to find how submissions we can skip forward
		ll lo = 1; ll hi = 1e9;
		while (lo < hi) {
			ll mid = (lo + hi + 1) / 2;
			// Check if 'mid' submissions crosses the 'cross' limit.
			if (floor(skip_submissions(a, b, E, mid)) == cross) {
				lo = mid;
	  		} else {
				hi = mid - 1;
			}
		}
		/*
		Skip forward 'lo' submissions or the remaining amount of submissions
		if there are less than 'lo' submissions left.
		*/
		lo = min(lo, K);
		E = skip_submissions(a, b, E, lo);
		K -= lo;
	}
	cout << fixed << setprecision(20);
	cout << E + 1 << endl;
}
```

</CPPSection>

</LanguageSection>
