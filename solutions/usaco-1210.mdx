---
id: usaco-1210
source: USACO Gold 2022 February
title: Cow Camp
author: Aakash Gokhale
---

[Official Analysis](http://www.usaco.org/current/data/sol_triangles_silver_feb20.html)

## Solution
We can subtract $1$ from $T$ because we will always get the sample test case and add it to our final answer.

Let $E_x$ be the expected value of $x$ submissions. We are trying to find $E_k$. To get the expected value of the final submission, we can find the relation between $E_x$ and $E_{x - 1}$.


To do this we can find $E_x$ in terms of $E_{x -1}$ and $p_i$ which is the probability of getting exactly $i$ test cases.


The general rule is to resubmit only if the amount of test cases is less the expected value after $x$ submissions and to not resubmit if it is greater than the expected value. The equality case doesn't matter so we can just change less than into less than or equal (or greater than into greater or equal to).


So the first part of the expected value expression will be the sum of probabilities that the number of test cases is less than or equal to $E_{x - 1}$ multiplied by the expected value of $E_{x - 1}$.


The second part of the the expected value expression will the be the sum of the probabilities multiplied by the actual value of test cases that are greater than the expected value of $E_{x - 1}$.


So our final expression is

$$E_x = E_{x -1} \cdot \sum_{i=0}^{\lfloor E_{x - 1} \rfloor} p_i + \sum_{i=\lfloor E_{x - 1} + 1 \rfloor}^{T} i p_i$$

We can simulate this process trivially in $\mathcal{O}(TK)$. However, this can easily be sped up to $\mathcal{O}(T^2 + K)$ by pre-calculating $p_i$ and using a prefix sum. This gives us the first $9$ test cases but is not good enough.


In order to fully solve the question, we need to be able to process multiple values of $E_x$ in a single step. We can only do this if the values of $$\sum_{i=0}^{\lfloor E_{x - 1} \rfloor} p_i$$ and $$\sum_{i=\lfloor E_{x - 1} + 1 \rfloor}^{T} i p_i$$ don't change between queries.


We can see this when we let $$a = \sum_{i=0}^{\lfloor E_{x - 1} \rfloor} p_i$$ and $$b = \sum_{i=\lfloor E_{x - 1} + 1 \rfloor}^{T} i p_i$$. Then our formula becomes

$E_x = E_{x - 1} \cdot a + b$

Since $a$ and $b$ are constant, we can extend this formula and get

$E_x = a \cdot (a \cdot ... (a \cdot E_{x - k} + b) ... + b) + b$

Simplifying gives us a geometric sequence.

$E_x = a^k \cdot E_{x - k} + a^{k - 1}b + a^{k - 2} + ... + b$

We can rewrite the second through last term using the formula for a geometric series.

$E_x = a^k \cdot E_{x - k} + \frac{b(a^k - 1)}{a - 1}$


Essentially we can binary search on the next value that will change the values of $$\sum_{0}^{\lfloor E_{x - 1} \rfloor} p_i$$. Since there are at most $T$ values of $E_x$, the resulting time complexity will be $\mathcal{O}(T^2 + T\log(K))$

## Implementation
**Time Complexity:** $\mathcal{O}(T^2 + T\logK)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using db = long double;

db prob[1001][1001];
db pref_prob[1001];
db pref_exp[1001];

// Function to skip ahead x submissions with constants a and b with the current expected value set to E.
db f(db a, db b, db E, ll x) {
  	return pow(a, x) * E + b * (pow(a, x) - 1) / (a - 1);
}

int main() {
	cout << fixed << setprecision(20);
	int T; ll K; cin >> T >> K; T--;
  
	// Precompute probablity of choosing exactly i test cases using Pascal's Identity.
	prob[0][0] = 1;
	for (int i = 1; i <= T; i++) {
		prob[i][0] = prob[i - 1][0] / 2;
		for (int j = 1; j <= T; j++) prob[i][j] = (prob[i - 1][j] + prob[i - 1][j - 1]) / 2;
	}
  
	// Create prefix sum of probablity
	pref_prob[0] = prob[T][0];
	for (int i = 1; i <= T; i++) pref_prob[i] = pref_prob[i - 1] + prob[T][i];
						
	// Create prefix sum of expected value
	pref_exp[0] = 0;
	for (int i = 1; i <= T; i++) pref_exp[i] = pref_exp[i - 1] + prob[T][i] * i;
  
	db E = 0;
	while (K) {
		// Find the floor of the current expected value which acts as the limit of how many submissions we can skip forward.
		ll cross = (ll) floor(E);

		// Find constants a and b
		db a = pref_prob[cross], b = pref_exp[T] - pref_exp[cross];

		// Binary search to find how submissions we can skip forward
		ll lo = 1; ll hi = 1e9;
		while (lo < hi) {
			ll mid = (lo + hi + 1) / 2;
			// Check if 'mid' submissions crosses the 'cross' limit.
			if (floor(f(a, b, E, mid)) == cross) {
				lo = mid;
	  		} else {
				hi = mid - 1;
			}
		}
		// Skip forward 'lo' submissions or the remaining amount of submissions if there are less than 'lo' submissions left.
		lo = min(lo, K);
		E = f(a, b, E, lo);
		K -= lo;
	}
	cout << E + 1 << endl;
}
```

</CPPSection>

</LanguageSection>
