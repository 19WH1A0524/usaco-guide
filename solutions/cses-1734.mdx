---
id: cses-1734
source: CSES
title: Distinct Values Queries
author: Benjamin Qi, Andrew Wang, Ã“scar Garries, Chuyang Wang
---

<Spoiler title="Hint">

Sort the queries in a specific order before answering them.

</Spoiler>

<Spoiler title="Solution">

**Time Complexity:** $\mathcal{O}(N\log{N})$

We answer the queries from right to left, sorted by their left indices. By using a BIT, we can keep track of indices that contain distinct values. For every value $arr[i]$, we set the latest (i.e. the left-most) index in $bit[i]$ to $1$. If this value appeared before, we set the last used index back to $0$. Then, we can answer all queries at the current index $i$ by summing up the values between $[i, b]$. This ensures later indices after $i$ are included in the BIT to accurately answer queries.

<LanguageSection>

<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;

struct BIT {
	int size;
	vector<int> bit;
	BIT(int n) : size(n), bit(n, 0) {}
	void update(int x, int v) {
		for (; x < size; x += x & (-x)) {
			bit[x] += v;
		}
	}
	/** @return sum of the values in [0,b] */
	int query(int b) {
		int result = 0;
		for (; b > 0; b -= b & (-b)) {
			result += bit[b];
		}
		return result;
	}
};

int main() {
	int n, q;
	cin >> n >> q;

	// arr, queries are 1-indexed.
	vector<int> arr(n + 1);
	vector<vector<pair<int, int>>> queries(n + 1);
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	for (int i = 0; i < q; i++) {
		int a, b;
		cin >> a >> b;
		queries[a].push_back({b, i});
	}

	// BIT also has to be 1-indexed, or the bitwise operator won't work.
	BIT bit(n + 1);
	// last_index[val] is the left-most index where arr[last_index[val]] = val.
	map<int, int> last_index;
	vector<int> solution(q, -1);
	// Update the indices and answer queries from right to left.
	for (int i = n; i > 0; i--) {
		int val = arr[i - 1];
		/*
		 * If val already appeared earlier, then the saved value is no
		 * longer the left-most index, so erase it from our BIT.
		 */
		if (last_index.count(val) > 0) bit.update(last_index[val], -1);
		// i becomes the left-most index.
		last_index[val] = i;
		bit.update(i, 1);

		// Answer all queires with a == i.
		for (auto &qr : queries[i]) {
			/*
			 * The solution for this query is bit[i,b].
			 * This equals bit[0,b] since bit[0,i-1] = 0.
			 */
			solution[qr.second] = bit.query(qr.first);
		}
	}

	for (auto &a : solution) {
		cout << a << "\n";
	}
}
```
</CPPSection>
</LanguageSection>

</Spoiler>
