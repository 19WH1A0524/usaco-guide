---
id: usaco-1233
source: USACO Gold 2022 Open
title: Apple Catching
author: Qi Wang
---

[Official Analysis (Java)](http://www.usaco.org/current/data/sol_prob1_gold_open22.html)

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;


struct Item {
	int q, t, x, n;

	// cow must arrive before apple hits the number line
	// let item i be cow and item j be apple
	// ti <= tj and abs(xi-xj) <= tj-ti can be expanded into the following:
	// xj-tj <= xi-ti 
	// xi+ti <= xj+tj
	// we can represent each item as a point (xi - ti, xi + ti)
	// for each cow as long as the apple item is to its left and up it is a valid point
	// therefore we first sort by xi - ti and then greedily select apples based on xi + ti
	bool operator<(const Item& y) {
		if (x - t == y.x - y.t)
			return q > y.q;

		return x - t < y.x - y.t;
	}
} p[200005];


int main() {
	int N;
	map<int, int> pts; // stores how many apples are at each point defined above
	cin >> N;
	for(int i = 0; i < N; i++){
		cin >> p[i].q >> p[i].t >> p[i].x >> p[i].n;
	}

	sort(p, p + N);

	int ans = 0;
	for(int i = 0; i < N; i++) {
		if (p[i].q == 2) {
			pts[p[i].x + p[i].t] += p[i].n;
		}
		else {
			int n = p[i].n;
			// greedily assign cows to the closest points
			while (n) {
				map<int, int>::iterator it = pts.lower_bound(p[i].x + p[i].t);

				if (it == pts.end()) break;
				int u = min(n, it->second);

				if (u == it->second) {
					mpp.erase(it);
				}
				else {
					it->second -= u;
				}

				n -= u;
				ans += u;
			}
		}
	}

	cout << ans << endl;
}
```

</CPPSection>

</LanguageSection>