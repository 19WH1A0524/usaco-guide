---
id: cses-1706
source: CSES
title: School Excursion
author: Brebenel Mihnea
---

## Explanation

The solution is based on DSU ([Disjoin Set Union](https://usaco.guide/gold/dsu?lang=cpp))
For example: If 2 and 3 want  the same thing and 3 and 4 want the same think, so it means that 2, 3 and 4 want the same thing. After we determine the components, we need to find out every combination of them. To do that, we use a knapsack DP (you can find a good tutorial [here](https://usaco.guide/gold/knapsack?lang=cpp)). But it would take $O(N ^ 2)$, which will cause TLE. In order to speed it up, we use a bitset as a knpasack. The final complexity is $\mathcal{O}(N\log^2N)$

## Implementation

**Time Complexity:** $\mathcal{O}(N\log^2N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bitset>
#include <iostream>
#include <vector>

using namespace std;

const int NMAX = 2e5;

int n, m;

class DSU {  // Disjoint Set Union
  private:
	int t[NMAX], sz[NMAX];

  public:
	DSU() {
		for (int i = 1; i < NMAX; i++) {
			t[i] = i;
			sz[i] = 1;
		}
	}
	int FindSize(int x) { return sz[FindRoot(x)]; }
	int FindRoot(int x) {
		if (t[x] == x) return x;
		t[x] = FindRoot(t[x]);
		return t[x];
	}
	void unite(int x, int y) {
		x = FindRoot(x), y = FindRoot(y);
		sz[y] += sz[x];
		t[x] = y;
	}
} ds;

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d %d", &x, &y);
		ds.unite(x, y);
	}
	vector<int> sizes;
	for (int i = 1; i <= n; i++) {
		if (ds.FindRoot(i) != i) continue;
		sizes.push_back(ds.FindSize(i));
	}

	bitset<100003> dp;
	dp[0] = 1;
	for (auto sz : sizes) dp |= dp << sz;

	// The above line shifts the knapsack to the right by sz bits

	for (int i = 1; i <= n; i++) cout << dp[i];
	puts("");
}
```

</CPPSection>
<PySection>

```py
class DisjointSet:
	parent = {}
	sz = []

	def makeSet(self, sz):
		# create `n` disjoint sets (one for each item)
		self.sz.append(1)
		for i in range(1, sz + 1):
			self.parent[i] = i
			self.sz.append(1)

	def Find(self, k):
		if self.parent[k] == k:
			return k
		return self.Find(self.parent[k])

	def FindSize(self, x):
		return self.sz[self.Find(x)]

	def Union(self, a, b):
		x = self.Find(a)
		y = self.Find(b)
		self.sz[y] += self.sz[x]
		self.parent[x] = y


n, m = map(int, input().split(" "))

ds = DisjointSet()
ds.makeSet(100003)

for i in range(0, m):
	x, y = map(int, input().split(" "))
	ds.Union(x, y)

sizes = []
for i in range(1, n + 1):
	if ds.Find(i) == i:
		sizes.append(ds.FindSize(i))
num = 1
for i in sizes:
	num = num | num << i
string = str(bin(num))
print(string[3:len(string)])
```

</PySection>
</LanguageSection>
