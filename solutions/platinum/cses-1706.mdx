---
id: cses-1706
source: CSES
title: School Excursion
author: Brebenel Mihnea
---

## Explanation

The solution is based on DSU ([Disjoint Set Union](/gold/dsu)).
For example: If 2 and 3 want the same thing and 3 and 4 want the same thing it means that 2, 3 and 4 want the same thing. After we determine the components we need to find out every combination of them. To do that we use a knapsack DP (you can find a good tutorial [here](/gold/knapsack)). But it would take $\mathcal{O}(N ^ 2)$ which will cause TLE. In order to speed it up we use a bitset as a knapsack. The final complexity is $\mathcal{O}(N\log N)$ .

## Implementation

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>
<PySection>

```py
class DisjointSet:
	parent = {}
	sz = []

	def make_set(self, sz):
		# create `n` disjoint sets (one for each item)
		self.sz.append(1)
		for i in range(1, sz + 1):
			self.parent[i] = i
			self.sz.append(1)

	def find(self, k):
		if self.parent[k] == k:
			return k
		return self.find(self.parent[k])

	def find_size(self, x):
		return self.sz[self.find(x)]

	def union(self, a, b):
		x = self.find(a)
		y = self.find(b)
		self.sz[y] += self.sz[x]
		self.parent[x] = y


n, m = map(int, input().split(" "))

ds = DisjointSet()
ds.make_set(n)

for i in range(0, m):
	x, y = map(int, input().split(" "))
	ds.union(x, y)

sizes = []
for i in range(1, n + 1):
	if ds.find(i) == i:
		sizes.append(ds.find_size(i))
num = 1
for i in sizes:
	num = num | num << i
string = str(bin(num))
print(string[3 : len(string)])
```

</PySection>
</LanguageSection>
