---
id: cf-600E
source: CF
title: Lomsat gelral
author: Chongtian Ma
---

[Official Analysis](https://codeforces.com/blog/entry/21827)

## Implementation

As explained in the official analysis, when we use small to large merging on data structures such as sets and maps, we optimize the amount of operations from $$\mathcal{O}(N^2 \log N)$ to $\mathcal{O}(N \log^2 N)$. We can take advantage of this to store all kinds of information related to colors, their sum, and their occurrences.

**Time Complexity:** $\mathcal{O}(N \log^2 N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MAXN = 1e5;
array<ll, MAXN> color;
array<ll, MAXN> ans;
vector<int> g[MAXN];

// col_cnt[i][j] = number of occurrences of color j in i
map<ll, ll> col_cnt[MAXN];
// sum_occur[i][j] = sum of colors having occurrence j in subtree i
map<ll, ll> sum_occur[MAXN];

void dfs(int node, int p) {
	// initialize this node
	col_cnt[node][color[node]] += 1;
	sum_occur[node][1] += color[node];

	for (int i : g[node]) {
		if (i == p) { continue; }
		dfs(i, node);
		// retrieve the biggest map so we have less to merge
		if (col_cnt[node].size() < col_cnt[i].size()) {
			col_cnt[node].swap(col_cnt[i]);
			sum_occur[node].swap(sum_occur[i]);
		}
		// update bigger map with information from smaller map
		for (auto [col, cnt] : col_cnt[i]) {
			// remove old occurrences
			if (col_cnt[node].count(col)) {
				sum_occur[node][col_cnt[node][col]] -= col;
			}
			// add new occurrences
			col_cnt[node][col] += cnt;
			sum_occur[node][col_cnt[node][col]] += col;
		}
	}

	// retrieve the sum with the biggest j
	ans[node] = sum_occur[node].rbegin()->second;
}

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) { cin >> color[i]; }
	for (int i = 0; i < n - 1; i++) {
		int u, v;
		cin >> u >> v;
		g[--u].push_back(--v);
		g[v].push_back(u);
	}

	dfs(0, 0);

	for (int i = 0; i < n; i++) { cout << ans[i] << " "; }
}
```

</CPPSection>
</LanguageSection>
