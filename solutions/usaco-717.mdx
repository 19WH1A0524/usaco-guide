---
id: usaco-717
source: USACO Gold 2017 December
title: Why Did the Cow Cross the Road
author: Qi Wang, Jeffrey Zhang
---

[Official Analysis](http://www.usaco.org/current/data/sol_visitfj_gold_feb17.html)

## Implementation

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;

//Possible directions a cow can go to eat grass
int Dx[] = {1, 0, -1, 0, 3, 0, -3, 0, 2, 2, 1, 1, -1, -1, -2, -2};
int Dy[] = {0, 1, 0, -1, 0, 3, 0, -3, 1, -1, 2, -2, 2, -2, 1, -1};

int main() {
    ifstream fin("visitfj.in");
    ofstream fout("visitfj.out");

    int n, t;
    fin >> n >> t;
    vector<vector<int>> field(n, vector<int>(n));
    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            fin >> field[i][j];
        }
    }

    /* 
     * There are 16 possible tiles a cow can reach in 3 moves
     * Form edges between those tiles and with assigned weight:
     * (the time it takes to eat the tile) + 3 * t
     * If the tile is less than 3 manhattan distance to farmer John's tile,
     * form an edge between those two tiles also.
     * The problem is now simple dijkstra
     */
    vector<vector<int>> dist(n, vector<int>(n, INT_MAX));
    vector<vector<bool>> visited(n, vector<bool>(n));
    dist[0][0] = 0;
    priority_queue<pair<int, pii>> dijkstra;
    dijkstra.push(make_pair(0, make_pair(0,0)));
    while (dijkstra.size()){
        int x, y;
        tie(x, y) = dijkstra.top().ss;
        dijkstra.pop();
        if (visited[x][y]){
			continue;
		}
        visited[x][y] = true;
        for (int i = 0; i < 16; i++){
            int dx = x + Dx[i], dy = y + Dy[i];
            if (dx < 0 || dx >= n || dy < 0 || dy >= n) continue;
            if (dist[dx][dy] > dist[x][y] + 3 * t + field[dx][dy]){
                dist[dx][dy] = dist[x][y] + 3 * t + field[dx][dy];
                dijkstra.push(make_pair(-dist[dx][dy], make_pair(dx,dy)));
            }
        }
        int manhattan = n - x - 1 + n - y - 1;
        if (manhattan < 3){
            dist[n - 1][n - 1] = min(dist[n - 1][n - 1], 
									 dist[x][y] + manhattan * t);
        }
    }

    fout << dist[n - 1][n - 1];

    return 0;
}
```

</CPPSection>


<JavaSection>

```java
import java.util.*;
import java.io.*;

public class VisitFJ {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("visitfj");

		// Possible paths cow can take
		int[] dx = {0, 1, 2, 3, 0, 1, 2, -1, -2, -3, -1, -2, 1, -1, 0, 0};
		int[] dy = {3, 2, 1, 0, -3, -2, -1, 2, 1, 0, -2, -1, 0, 0, 1, -1};

		int N = io.nextInt();
		int T = io.nextInt();

		int[][] w = new int[N][N];
		int[][] dist = new int[N][N];

		for (int i = 0; i < N; i++) {
			Arrays.fill(dist[i], Integer.MAX_VALUE);
			for (int j = 0; j < N; j++) {
				w[i][j] = io.nextInt();
			}
		}

		PriorityQueue<Edge> pq = new PriorityQueue<>();
		pq.add(new Edge(new int[]{0, 0}, 0));
		while (!pq.isEmpty()) {
			Edge cur = pq.poll();
			int[] pos = cur.t;

			int d = N - 1 - pos[0] + N - 1 - pos[1];

			// If within 3 blocks away, update the minimum weight needed
			if (d < 3 && d > 0) {
				dist[N - 1][N - 1] = Math.min(dist[N - 1][N - 1], cur.w + T * d);
			}

			for (int i = 0; i < dx.length; i++) {
				int nx = pos[0] + dx[i];
				int ny = pos[1] + dy[i];

				// Continue if new point is out of bound
				if (nx < 0 || nx >= N || ny < 0 || ny >= N) {
					continue;
				}

				int nw = cur.w + w[nx][ny] + T * 3;
				
				// If new distance is greater than current minimum distance, it is not needed
				if (nw > dist[nx][ny]) {
					continue;
				}
				dist[nx][ny] = nw;

				pq.add(new Edge(new int[]{nx, ny}, nw));
			}
		}

		io.println(dist[N - 1][N - 1]);
		io.close();
	}

	private static class Edge implements Comparable<Edge>{
		int[] t;
		int w;
		public Edge(int[] t, int w) {
			this.t = t;
			this.w = w;
		}

		@Override
		public int compareTo(Edge o) {
			return w - o.w;
		}
	}

	//CodeSnip{Kattio}
}
```

</JavaSection>
</LanguageSection>
