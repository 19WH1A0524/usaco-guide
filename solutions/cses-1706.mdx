---
id: cses-1706
source: CSES
title: School Excursion
author: Brebenel Mihnea
---
## Solution
**Time complexity:** $\mathcal{O}(N\log^2N)$

The solution is based on DSU ([Disjoin Set Union](https://usaco.guide/gold/dsu?lang=cpp))
For example: If 2 and 3 want  the same thing and 3 and 4 want the same think, so it means that 2, 3 and 4 want the same thing. After we determine the components, we need to find out every combination of them. To do that, we use a knapsack DP (you can find a good tutorial [here](https://usaco.guide/gold/knapsack?lang=cpp)). But it would take $O(N ^ 2)$, which will cause TLE. In order to speed it up, we use a bitset as a knpasack. The final complexity is $\mathcal{O}(N\log^2N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bitset>
#include <iostream>
#include <vector>

using namespace std;

const int NMAX = 2e5;

int n, m;

class DSU {  // Disjoint Set Union
  private:
	int t[NMAX], sz[NMAX];

  public:
	DSU() {
		for (int i = 1; i < NMAX; i++) {
			t[i] = i;
			sz[i] = 1;
		}
	}
	int FindSize(int x) { return sz[FindRoot(x)]; }
	int FindRoot(int x) {
		if (t[x] == x) return x;
		t[x] = FindRoot(t[x]);
		return t[x];
	}
	void unite(int x, int y) {
		x = FindRoot(x), y = FindRoot(y);
		sz[y] += sz[x];
		t[x] = y;
	}
} ds;

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d %d", &x, &y);
		ds.unite(x, y);
	}
	vector<int> sizes;
	for (int i = 1; i <= n; i++) {
		if (ds.FindRoot(i) != i) continue;
		sizes.push_back(ds.FindSize(i));
	}

	bitset<100003> dp;
	dp[0] = 1;
	for (auto sz : sizes) dp |= dp << sz;

	// The above line shifts the knapsack to the right by sz bits

	for (int i = 1; i <= n; i++) cout << dp[i];
	puts("");

	return 0;
}
```
</CPPSection>

</LanguageSection>
