---
id: usaco-1276
source: USACO Bronze 2023 January
title: Air Cownditioning II
author: Chuyang Wang
---

[Official Analysis](http://www.usaco.org/current/data/sol_prob2_bronze_jan23.html)

## Explanation

Since $M = 10$ is given, we can iterate through all $2^{10}$ possible subsets of
air conditioners. For each of them, we check if this subset of air conditioners
satisfy the requirements of the cows by iterating through all possible positions
$i \in [1;100]$. For each position $i$, we can iterate through all available air
conditioners in the current subset to find out the temperature reduced at $i$
and iterate through all cows to find the cow at this position and its demand. If
the requirement at each position is fulfilled, we update the minimal cost
accordingly. 

There are two ways to generate all subsets of air conditioners: Using recursion
or a bit mask.


## Solution 1: Subset with Recursion

**Time Complexity:** $\mathcal{O}(2^M \cdot 100 \cdot (M + N))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, M;
// {s, t, c}
vector<array<int, 3>> cows;
// {a, b, p, m}
vector<array<int, 4>> air_conditioners;
// uses[i] == true: the i-th air conditioner is used
vector<bool> uses;
// the minimum amount of money needed to keep all cows comfortable
int min_cost = 1e9;

/**
 * Based on 'uses', determine if the current subset of air conditioners suffices
 * the constraints, and if so, update the minimum cost
 */
void update() {
	bool is_feasible = true;

	// iterate through all positions to check if the current subset is feasible
	for (int i = 1; i <= 100; i++) {
		// iterate through air conditioners to find the current cooling units
		int cooling = 0;
		for (int j = 0; j < M; j++) {
			if (!uses[j]) continue;
			auto &[a, b, p, m] = air_conditioners[j];
			if (a <= i && i <= b) { cooling += p; }
		}

		// iterate through cows to find the current cow
		int cow_requirement = 0;
		for (int j = 0; j < N; j++) {
			auto &[s, t, c] = cows[j];
			if (s <= i && i <= t) {
				cow_requirement = c;
				break;
			}
		}

		// For each position, the requirement of the cow must be met
		if (cooling < cow_requirement) {
			is_feasible = false;
			break;
		}
	}

	if (is_feasible) {
		int cost = 0;
		for (int i = 0; i < M; i++) {
			if (uses[i]) { cost += air_conditioners[i][3]; }
		}
		min_cost = min(min_cost, cost);
	}
}

/**
 * Expand the subset, represented by 'uses', by choosing to (not) use the i-th
 * air conditioner
 */
void search(int i) {
	if (i == M) {
		update();
	} else {
		uses[i] = false;
		search(i + 1);
		uses[i] = true;
		search(i + 1);
	}
}

int main() {
	cin >> N >> M;

	for (int i = 0; i < N; i++) {
		int s, t, c;
		cin >> s >> t >> c;
		cows.push_back({s, t, c});
	}

	for (int i = 0; i < M; i++) {
		int a, b, p, m;
		cin >> a >> b >> p >> m;
		air_conditioners.push_back({a, b, p, m});
	}

	uses.assign(M, false);
	search(0);

	cout << min_cost << endl;
}
```

</CPPSection>

</LanguageSection>


## Solution 2: Subset with Bitmask

**Time Complexity:** $\mathcal{O}(2^M \cdot 100 \cdot (M + N))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Check if the given 'air_conditioners' satisfy the constraints of the cows
 */
bool check(vector<array<int, 3>> &cows,
		   vector<array<int, 4>> &air_conditioners) {
	// iterate through all positions to check if the current subset is feasible
	for (int i = 1; i <= 100; i++) {
		// iterate through air conditioners to find the current cooling units
		int cooling = 0;
		for (int j = 0; j < air_conditioners.size(); j++) {
			auto &[a, b, p, m] = air_conditioners[j];
			if (a <= i && i <= b) { cooling += p; }
		}

		// iterate through cows to find the current cow
		int cow_requirement = 0;
		for (int j = 0; j < cows.size(); j++) {
			auto &[s, t, c] = cows[j];
			if (s <= i && i <= t) {
				cow_requirement = c;
				break;
			}
		}

		// For each position, the requirement of the cow must be met
		if (cooling < cow_requirement) { return false; }
	}
	return true;
}

int main() {
	int N, M;
	cin >> N >> M;

	vector<array<int, 3>> cows;
	for (int i = 0; i < N; i++) {
		int s, t, c;
		cin >> s >> t >> c;
		cows.push_back({s, t, c});
	}

	vector<array<int, 4>> air_conditioners;
	for (int i = 0; i < M; i++) {
		int a, b, p, m;
		cin >> a >> b >> p >> m;
		air_conditioners.push_back({a, b, p, m});
	}

	int min_cost = 1e9;
	// use a bit mask to get all subsets
	for (int mask = 0; mask < (1 << M); mask++) {
		int cost = 0;
		vector<array<int, 4>> used_conditioners;
		for (int i = 0; i < M; i++) {
			if (mask & (1 << i)) {
				used_conditioners.push_back(air_conditioners[i]);
				cost += air_conditioners[i][3];
			}
		}

		if (check(cows, used_conditioners)) { min_cost = min(min_cost, cost); }
	}

	cout << min_cost << endl;
}
```

</CPPSection>

</LanguageSection>
