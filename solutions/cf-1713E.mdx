---
id: cf-1713E
source: Codeforces Div 2
title: Cross Swapping
author: Aakash Gokhale
---

## Solution

[Official Analysis](https://codeforces.com/blog/entry/105419)

Notice that $a[i][j]$ can only be swapped with $a[j][i]$ no matter which operations are performed.

In addition, we want to lexicographically sort the array. Thus, we can iterate and greedily process the array.

For all $j$ such that $i < j$ (we only need to consider each pair once and keeping $i < j$ will ensure this), we can determine whether we want to swap them or keep them the same.

If $a[i][j] > a[j][i]$, we want to swap them. If $a[i][j] < a[j][i]$ we want to keep them the same. If they are equal it doesn't matter.

However, it is possible that not all conditions can work together with each other and swapping something means we can't swap something else later on.

We can use the [Amogus Trick](https://codeforces.com/blog/entry/106407) to represent this problem. Create a disjoint set union of $2n$ nodes where node $i$ represents the state where the operation is performed on $i$ and $i + n$ represents the state where operation is not performed on $i$.

As we are iterating greedily through the array, we can merge ($i$ and $j$) and ($i + n$ and $j + n$) if we don't want to swap. This works because if we swap neither or swap both the arrangement remains the same.
If we do want to swap we can merge ($i$ and $j + n$) and ($i + n$ and $j$). This works because if we swap exactly one of these, then the arrangement will change. 

After this we can construct the answer.

We can iterate over the entire grid. If it is a diaganal it will never change. If $a[i][j] == a[j][i]$ then we can manually set them to normal (since we didn't merge them in the disjoint set union when comparing them the states might have not been merged). If it is not a diaganol we can check whether $i$ and $j$ are merged in the disjoint set union. If they aren't then we will swap $a[i][j]$ and $a[j][i]$. Otherwise we will keep them the same.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using vi = vector<int>;

struct DSU {
	vi e;
	DSU(int n) {
		e = vi(n, -1);
	}
	int get(int x) {
		return e[x] < 0 ? x : e[x] = get(e[x]);
	}
	bool same(int a, int b) {
		return get(a) == get(b);
	}
	int size(int x) {
		return -e[get(x)];
	}
	bool unite(int x, int y) {
		x = get(x); y = get(y);
		if (x == y) return false;
		if (e[x] > e[y]) swap(x, y);
		e[x] += e[y]; e[y] = x;
		return true;
	}
};

void solve() {
	int n;
	cin >> n;
	int a[n][n];
	for (int i = 0; i < n; i++)
	  for (int j = 0; j < n; j++) cin >> a[i][j];
	DSU dsu(2 * n);
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) { // Only check each pair once and diagnals don't matter
			// If they are the same we should not merge either way because it could affect later merges
			if (a[i][j] == a[j][i]) continue;
			else if (a[i][j] > a[j][i]) {
				// Try to swap the elements
				if (dsu.get(i) != dsu.get(j)) { // Check if the states are already merged the opposite way
					dsu.unite(i, j + n);
					dsu.unite(j, i + n);
				}
			} else	{
				// Try to keep the elements the same
				if (dsu.get(i) != dsu.get(j + n)) { // Check if the states are already merged the opposite way
					dsu.unite(i, j);
					dsu.unite(i + n, j + n);
				}
			}
		}
	}
	// Construct the answer
	int ans[n][n];
	for (int i = 0; i < n; i++) {
		for (int j = i; j < n; j++) {
			/* If a[i][j] is part of a diagonal or the pair is equal (a[i][j] == a[j][i]),
			 * manually set it to be the same as the original array
			 */
			if (i == j) ans[i][j] = a[i][j];
			else if (a[i][j] == a[j][i]) ans[i][j] = ans[j][i] = a[i][j];
			else { // Otherwise check whether the i and j states are merged
				if (dsu.get(i) == dsu.get(j)) {
					ans[i][j] = a[i][j];
					ans[j][i] = a[j][i];
				} else {
					ans[i][j] = a[j][i];
					ans[j][i] = a[i][j];
				}
			}
		}
	}
  // Print the answer
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << ans[i][j] << " ";
		}
		cout << endl;
	}
}

int main() { 
	ios::sync_with_stdio(false); cin.tie(nullptr);
	int T = 1; cin >> T;
	while (T--) {
		solve();
	}
}
```

</CPPSection>

</LanguageSection>
